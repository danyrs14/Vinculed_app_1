<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="vinculed_app_1">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>vinculed_app_1</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
  <script>
    window.decodeQrFromBytes = async function(uint8Array) {
      return new Promise((resolve) => {
        try {
          const blob = new Blob([uint8Array], { type: 'image/png' });
          const url = URL.createObjectURL(blob);
          const img = new Image();
          
          img.onload = function() {
            URL.revokeObjectURL(url);
            
            // Fase 1: Estrategias básicas (sin morfología)
            const basicStrategies = [
              { scale: 1.0, invert: false, contrast: 1.0 },
              { scale: 1.5, invert: false, contrast: 1.0 },
              { scale: 2.0, invert: false, contrast: 1.0 },
              { scale: 0.75, invert: false, contrast: 1.0 },
              { scale: 1.0, invert: true, contrast: 1.0 },
              { scale: 1.0, invert: false, contrast: 1.3 },
              { scale: 1.5, invert: false, contrast: 1.3 },
              { scale: 1.0, invert: false, contrast: 1.5, brightness: 20 },
              { scale: 2.0, invert: false, contrast: 1.2 },
            ];
            
            for (const strategy of basicStrategies) {
              const result = tryDecode(img, strategy);
              if (result) {
                console.log('QR decoded with basic strategy:', strategy);
                resolve(result);
                return;
              }
            }
            
            // Fase 2: Estrategias con operaciones morfológicas para QRs de baja calidad
            // Esto rellena los "huecos" blancos dentro de los módulos negros
            const morphStrategies = [
              { scale: 1.5, dilate: 1, threshold: 128 },
              { scale: 2.0, dilate: 1, threshold: 128 },
              { scale: 2.0, dilate: 2, threshold: 128 },
              { scale: 1.5, dilate: 1, threshold: 100 },
              { scale: 2.0, dilate: 1, threshold: 100 },
              { scale: 2.5, dilate: 2, threshold: 128 },
              { scale: 3.0, dilate: 2, threshold: 128 },
              { scale: 2.0, dilate: 1, threshold: 150 },
              { scale: 1.5, dilate: 2, threshold: 128 },
            ];
            
            for (const strategy of morphStrategies) {
              const result = tryDecodeWithMorphology(img, strategy);
              if (result) {
                console.log('QR decoded with morphology strategy:', strategy);
                resolve(result);
                return;
              }
            }
            
            // Fase 3: Recortes del centro con morfología
            const cropRatios = [0.7, 0.6, 0.5];
            for (const cropRatio of cropRatios) {
              for (const morph of [{ scale: 2.0, dilate: 1 }, { scale: 2.5, dilate: 2 }]) {
                const result = tryDecodeWithCropAndMorph(img, cropRatio, morph);
                if (result) {
                  console.log('QR decoded with crop+morph, ratio:', cropRatio);
                  resolve(result);
                  return;
                }
              }
            }
            
            // Fase 4: Última oportunidad - estrategias adicionales
            const lastResort = [
              { scale: 0.75, invert: false, contrast: 1.0 },
              { scale: 1.0, invert: true, contrast: 1.0 },
              { scale: 1.0, invert: false, contrast: 1.5, brightness: 20 },
              { scale: 2.0, invert: false, contrast: 1.2 },
            ];
            
            for (const strategy of lastResort) {
              const result = tryDecode(img, strategy);
              if (result) {
                console.log('QR decoded with last resort strategy:', strategy);
                resolve(result);
                return;
              }
            }
            
            console.log('No QR code found after all strategies');
            resolve(null);
          };
          
          img.onerror = function() {
            URL.revokeObjectURL(url);
            console.error('Error loading image');
            resolve(null);
          };
          
          img.src = url;
        } catch (e) {
          console.error('decodeQrFromBytes error', e);
          resolve(null);
        }
      });
    };
    
    // Decodificación básica con escala, contraste e inversión
    function tryDecode(img, options) {
      const { scale, invert, contrast, brightness } = options;
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = Math.round(img.width * scale);
      canvas.height = Math.round(img.height * scale);
      
      // Aplicar filtros si es necesario
      if (contrast !== 1.0 || brightness) {
        ctx.filter = `contrast(${contrast}) brightness(${brightness ? (100 + brightness) + '%' : '100%'})`;
      }
      
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      
      let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      // Invertir colores si se solicita
      if (invert) {
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          data[i] = 255 - data[i];
          data[i + 1] = 255 - data[i + 1];
          data[i + 2] = 255 - data[i + 2];
        }
      }
      
      const code = jsQR(imageData.data, canvas.width, canvas.height, {
        inversionAttempts: "attemptBoth"
      });
      
      return code ? code.data : null;
    }
    
    // Decodificación con operaciones morfológicas para QRs de baja calidad
    function tryDecodeWithMorphology(img, options) {
      const { scale, dilate, threshold } = options;
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = Math.round(img.width * scale);
      canvas.height = Math.round(img.height * scale);
      
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      
      let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      // Paso 1: Convertir a escala de grises y binarizar
      const width = canvas.width;
      const height = canvas.height;
      const gray = new Uint8Array(width * height);
      const data = imageData.data;
      
      for (let i = 0; i < gray.length; i++) {
        const idx = i * 4;
        // Luminancia ponderada
        const lum = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
        gray[i] = lum < threshold ? 0 : 255;
      }
      
      // Paso 2: Dilatación de píxeles negros (rellena huecos blancos)
      // Esto es clave para las credenciales de baja calidad
      let current = gray;
      for (let d = 0; d < dilate; d++) {
        const next = new Uint8Array(current);
        for (let y = 1; y < height - 1; y++) {
          for (let x = 1; x < width - 1; x++) {
            const idx = y * width + x;
            // Si algún vecino es negro, este píxel se vuelve negro
            if (current[idx - 1] === 0 || current[idx + 1] === 0 ||
                current[idx - width] === 0 || current[idx + width] === 0 ||
                current[idx - width - 1] === 0 || current[idx - width + 1] === 0 ||
                current[idx + width - 1] === 0 || current[idx + width + 1] === 0) {
              next[idx] = 0;
            }
          }
        }
        current = next;
      }
      
      // Paso 3: Reconstruir imageData
      for (let i = 0; i < current.length; i++) {
        const idx = i * 4;
        const val = current[i];
        data[idx] = val;
        data[idx + 1] = val;
        data[idx + 2] = val;
      }
      
      const code = jsQR(data, width, height, {
        inversionAttempts: "attemptBoth"
      });
      
      return code ? code.data : null;
    }
    
    // Recorte central + morfología
    function tryDecodeWithCropAndMorph(img, cropRatio, morphOptions) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      const cropWidth = Math.round(img.width * cropRatio);
      const cropHeight = Math.round(img.height * cropRatio);
      const offsetX = Math.round((img.width - cropWidth) / 2);
      const offsetY = Math.round((img.height - cropHeight) / 2);
      
      const scale = morphOptions.scale || 2.0;
      canvas.width = Math.round(cropWidth * scale);
      canvas.height = Math.round(cropHeight * scale);
      
      ctx.drawImage(
        img,
        offsetX, offsetY, cropWidth, cropHeight,
        0, 0, canvas.width, canvas.height
      );
      
      let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      const width = canvas.width;
      const height = canvas.height;
      const gray = new Uint8Array(width * height);
      const data = imageData.data;
      const threshold = morphOptions.threshold || 128;
      
      for (let i = 0; i < gray.length; i++) {
        const idx = i * 4;
        const lum = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
        gray[i] = lum < threshold ? 0 : 255;
      }
      
      // Dilatación
      const dilate = morphOptions.dilate || 1;
      let current = gray;
      for (let d = 0; d < dilate; d++) {
        const next = new Uint8Array(current);
        for (let y = 1; y < height - 1; y++) {
          for (let x = 1; x < width - 1; x++) {
            const idx = y * width + x;
            if (current[idx - 1] === 0 || current[idx + 1] === 0 ||
                current[idx - width] === 0 || current[idx + width] === 0 ||
                current[idx - width - 1] === 0 || current[idx - width + 1] === 0 ||
                current[idx + width - 1] === 0 || current[idx + width + 1] === 0) {
              next[idx] = 0;
            }
          }
        }
        current = next;
      }
      
      for (let i = 0; i < current.length; i++) {
        const idx = i * 4;
        const val = current[i];
        data[idx] = val;
        data[idx + 1] = val;
        data[idx + 2] = val;
      }
      
      const code = jsQR(data, width, height, {
        inversionAttempts: "attemptBoth"
      });
      
      return code ? code.data : null;
    }
  </script>
</body>
</html>
